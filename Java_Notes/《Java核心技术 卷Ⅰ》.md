### 文字概念

- 面向对象（OOP):始终关注所制作的，不用关注用什么做，考虑业务逻辑（接口设计），人机交互是UI。首先从设计类开始，然后再往每个类中添加方法。

- 分布式：Java有一个丰富的例程库。用于处理HTTP、FTP之类的TCP/IP协议。Java应用程序能够通过URL打开和访问网络上对象。其便捷程度=访问本地文件。

- 多线程：摩尔定律完结，不追求更快的处理器，而要获得更多处理器，而且让他们一直工作。设计     并发程序操作多核处理器。
- 封装：将数据（属性或状态）和行为（对数据的操作（函数））组合在一个包中，并对对象使用者隐藏了数据的实现方式

----------


### 第四章：对象与类

**类是构造对象（属性+服务）的模板或蓝图。**
**由类构造对象的过程称为创建类的实例。**

##### 类的方法可以访问类的任何一个对象的私有域

##### 对象中的数据称为实例域

##### 操纵数据的过程称为方法

1.
a.**局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是      						  
                     在方法中，方法结束后，变量就会自动销毁。
 b.**成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成						 
                        员变量可以被类中方法、构造方法和特定类的语句块访问。
 c.**类变量**：类变量也声明在类中，方法体之外，但必须声明为static类型。

2.**public**:访问修饰符，控制程序其它部分对这段代码访问识别。

			·任何类的函数或定义初始化中可以调用、访问或定义变量。
	
	private：·这个类私有，只能用于成员变量、成员函数。
	
			·只有且针对这个类内部才能访问。

3.文件名必须与public类的名字匹配，在一个源文件中只能有一个公共类。

4.构造器与类同名，伴随new操作一起调用。

5.this表示隐式函数，将实例域与局部变量明显区分开需要获得或设置实例域的值。

	·一个私有的数据域
	
	·一个公有的域访问器方法
	
	·一个公有的域更改器方法

6**.静态域（类域）**：每个类只有一个域，它属于类，不属于任何独立的对象

7.**静态方法**：一种不能向对象实施操作的方法，Eg:boxing_glove:Math.pow(x,a)计算x^a，不使用Math对象

					·一个方法不需要访问对象状态，其所需参数都是通过显式参数提供
	
					·一个方法只需访问类的静态域

8.**重载**：多个方法有相同名字，不同参数，产生重载。

				一个类可以有多个构造方法，只要参数表不同，自动调用（同名不同参）

9.**方法参数**：①按值调用

					   ②按引用调用（都是拷贝）
	
					·一个方法不能修改一个基本数据类型（数值、布尔型）的参数
	
					·一个方法可改变一个对象的状态
	
					·一个方法不能让对象参数引用一个新的对象
	
					   ③一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。在Java中，任何对象变							量的值都是对存储在另外一个地方的一个对象的引用
	
	Eg:moneybag:salary将引用这个参数，而不是实例域，this.salary可以访问实例域

##### 类的设计技巧：

> 		·一定保证数据私有
> 		
> 			Important;绝对不要破坏封装性。
> 		
> 		·一定要数据初始化 
> 		
> 			Java不对局部变量进行初始化，但会对对象的实例域初始化。显式的初始化。
> 		
> 		·不要在类中使用过多的基本类型
> 		
> 			用其他的类代替多个相关基本类型的使用
> 		
> 		·不是所有的域都需要独立的域访问器
> 		
> 		·将职责过多的类进行分解
> 		
> 		·类名和方法名要能够体现职责
> 		
> 		·优先使用不可变类


### 第五章：继承
**利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上还可以添加一些新的方法和域。**
#####  定义子类，extends表继承（Java只有公有继承）extends表明正在构造的新类派生于一个已存在的类

 - 已存在的类称为：**超类**、基类、或父类 
 - 新类称为:**子类**、派生类或孩子类（集合关系）

 1. 在通过扩展超类定义子类的时候，仅需指出子类与超类的不同之处
 2. 通用方法放在超类，将特殊用途的方法置于子类，关键字super调用超类的方法



   ```
 public Manager(String name,double salary,int year,int month,int day)
    {
        super(name,salary,year,month,day)
    }

·只可在第一行使用，调用超类中含有（）参数的构造器。
   ```
##### 继承层次

——由一个公共超类派生出来的所有类的集合被称为继承层次。

在继承层次，从某个特定的类到其祖先的路径被称为该类的继承链。

##### 阻止继承：final类和方法

·不允许扩展的类被称为final类

·将方法或声明为final，主要目的是：确保它们不会在子类中改变语义。

##### 强制类型转换

    Manager boss = (Manager) staff[0]

 - 只能在继承层次内进行类型转换
  
 - 在将超类转换成子类之前，应该使用instanceof检查
   ```
 if(staff[1] instanceof Manager)
    
    	{
    
    		boss = (Manager)staff[1];
    
    	}
**抽象类**

——体现继承关系，父类与派生类之间必须存在“is-a”关系，即父类与派生类之间在概念本质应相同（自下而上的过程）设计抽象类是自下而上的过程,因为调用者子类需要某些属性和特有行为,所以调用者继承抽象类 

- 目的：开发者继承抽象类是为了使用抽象类的属性和行为

  为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的

- 扩展抽象类有两种选择：

  1.在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类。

  2.定义全部的抽象方法，如此子类就不是抽象的了

抽象类不能被实例化。一个声明为abstract，就不能创建这个类的对象。

`下面定义一个扩展抽象类Person的具体子类Student：`

```
public class Student extends Person

{	

​	private String major;

​	public Student(String name,String major){

​			super(name);

​			this.major = major;

​	}

​	public String getDescription(){

​		return"a student majoring in" + major;	

​	}

}


```



